<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyRT_DISORT.eos API documentation</title>
<meta name="description" content="eos.py contains data structures to hold equation of state variables used
throughout the model." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyRT_DISORT.eos</code></h1>
</header>
<section id="section-intro">
<p>eos.py contains data structures to hold equation of state variables used
throughout the model.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;eos.py contains data structures to hold equation of state variables used
throughout the model.
&#34;&#34;&#34;
import warnings
import numpy as np
from scipy.constants import Boltzmann
from pyRT_DISORT.utilities.array_checks import ArrayChecker
from scipy.integrate import quadrature as quad


# TODO: Mike said to do this in log(z) space. Is this still necessary?
# TODO: I ask for a z grid to interpolate onto but a P grid would be a nice
#  option
class ModelEquationOfState:
    &#34;&#34;&#34;Compute equation of state variables on a model grid.

    ModelEquationOfState accepts altitudes [km], pressures [Pa],
    temperatures [K], and number densities [particles / m**3], along with the
    altitudes where the model is defined. It linearly interpolates
    pressures and temperatures onto this new grid and assumes the ideal gas law
    to calculate the number density at the new grid. It also computes the
    column density within each layer using Gaussian quadrature.

    &#34;&#34;&#34;

    def __init__(self, altitude_grid: np.ndarray, pressure_grid: np.ndarray,
                 temperature_grid: np.ndarray, number_density_grid: np.ndarray,
                 altitude_boundaries: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        altitude_grid: np.ndarray
            The altitudes [km] at which the equation of state variables are
            defined.
        pressure_grid: np.ndarray
            The pressures [Pa] at the corresponding altitudes.
        temperature_grid: np.ndarray
            The temperatures [K] at the corresponding altitudes.
        number_density_grid: np.ndarray
            The number densities [particles / m**3] at the corresponding
            altitudes.
        altitude_boundaries: np.ndarray
            The desired altitudes [km] of the model boundaries.

        Raises
        ------
        IndexError
            Raised if the input grids do not have the same shape.
        TypeError
            Raised if any of the inputs are not np.ndarrays.
        ValueError
            Raised if any of the inputs have unphysical values.

        &#34;&#34;&#34;
        self.__altitude_grid = altitude_grid
        self.__pressure_grid = pressure_grid
        self.__temperature_grid = temperature_grid
        self.__number_density_grid = number_density_grid
        self.__altitude_boundaries = altitude_boundaries

        self.__raise_error_if_input_variables_are_bad()
        self.__flip_grids_if_altitudes_are_mono_decreasing()

        self.__n_layers = len(self.__altitude_boundaries) - 1
        self.__pressure_boundaries = self.__make_pressure_model()
        self.__temperature_boundaries = self.__make_temperature_model()
        self.__number_density_boundaries = self.__make_number_density_model()
        self.__column_density_layers = self.__compute_column_density_layers()

    def __raise_error_if_input_variables_are_bad(self) -&gt; None:
        self.__raise_error_if_altitude_grid_is_bad()
        self.__raise_error_if_pressure_grid_is_bad()
        self.__raise_error_if_temperature_grid_is_bad()
        self.__raise_error_if_number_density_grid_is_bad()
        self.__raise_error_if_altitude_model_is_bad()
        self.__raise_index_error_if_grids_are_not_same_shape()

    def __raise_error_if_altitude_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(self.__altitude_grid, &#39;altitude_grid&#39;)

    def __raise_error_if_pressure_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(self.__pressure_grid, &#39;pressure_grid&#39;)

    def __raise_error_if_temperature_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(
            self.__temperature_grid, &#39;temperature_grid&#39;)

    def __raise_error_if_number_density_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(
            self.__number_density_grid, &#39;number_density_grid&#39;)

    def __raise_index_error_if_grids_are_not_same_shape(self) -&gt; None:
        if not self.__altitude_grid.shape == self.__temperature_grid.shape == \
               self.__pressure_grid.shape == self.__number_density_grid.shape:
            raise IndexError(&#39;All input grids must have the same shape.&#39;)

    def __raise_error_if_altitude_model_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(
            self.__altitude_boundaries, &#39;altitude_boundaries&#39;)
        self.__raise_value_error_if_model_altitudes_are_not_mono_decreasing()
        self.__raise_value_error_if_too_few_layers_are_included()

    def __raise_error_if_grid_is_bad(self, array: np.ndarray, name: str) \
            -&gt; None:
        try:
            checks = self.__make_grid_checks(array)
        except TypeError:
            raise TypeError(f&#39;{name} is not a np.ndarray.&#39;) from None
        if not all(checks):
            raise ValueError(
                f&#39;{name} must be a 1D array containing positive, finite &#39;
                f&#39;values.&#39;)

    @staticmethod
    def __make_grid_checks(grid: np.ndarray) -&gt; list[bool]:
        grid_checker = ArrayChecker(grid)
        checks = [grid_checker.determine_if_array_is_1d(),
                  grid_checker.determine_if_array_is_finite(),
                  grid_checker.determine_if_array_is_non_negative()]
        return checks

    def __raise_value_error_if_model_altitudes_are_not_mono_decreasing(self) \
            -&gt; None:
        model_checker = ArrayChecker(self.__altitude_boundaries)
        if not model_checker.determine_if_array_is_monotonically_decreasing():
            raise ValueError(&#39;altitude_model must be monotonically decreasing.&#39;)

    def __raise_value_error_if_too_few_layers_are_included(self) -&gt; None:
        if len(self.__altitude_boundaries) &lt; 2:
            raise ValueError(&#39;The model must contain at least 2 boundaries &#39;
                             &#39;(i.e. one layer).&#39;)

    def __flip_grids_if_altitudes_are_mono_decreasing(self) -&gt; None:
        altitude_checker = ArrayChecker(self.__altitude_grid)
        if altitude_checker.determine_if_array_is_monotonically_decreasing():
            self.__altitude_grid = np.flip(self.__altitude_grid)
            self.__pressure_grid = np.flip(self.__pressure_grid)
            self.__temperature_grid = np.flip(self.__temperature_grid)
            self.__number_density_grid = np.flip(self.__number_density_grid)

    def __make_pressure_model(self) -&gt; np.ndarray:
        return self.__interpolate_variable_to_model_altitudes(
            self.__pressure_grid)

    def __make_temperature_model(self) -&gt; np.ndarray:
        return self.__interpolate_variable_to_model_altitudes(
            self.__temperature_grid)

    def __make_number_density_model(self) -&gt; np.ndarray:
        return self.__pressure_boundaries / \
               (Boltzmann * self.__temperature_boundaries)

    def __interpolate_variable_to_model_altitudes(self, grid: np.ndarray) \
            -&gt; np.ndarray:
        return np.interp(self.__altitude_boundaries, self.__altitude_grid, grid)

    def __compute_column_density_layers(self) -&gt; np.array:
        with warnings.catch_warnings():
            warnings.filterwarnings(&#34;ignore&#34;)
            colden = [quad(self.__make_n_at_altitude,
                           self.__altitude_boundaries[i + 1],
                           self.__altitude_boundaries[i])[0]
                      for i in range(self.__n_layers)]
            return np.array(colden)

    # TODO: This logic seems to duplicate functions above... try to fix
    def __make_n_at_altitude(self, z: float) -&gt; float:
        p = np.interp(z, self.__altitude_grid, self.__pressure_grid)
        t = np.interp(z, self.__altitude_grid, self.__temperature_grid)
        return 1 / Boltzmann * p / t

    @property
    def altitude_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the input altitudes at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary altitudes.

        &#34;&#34;&#34;
        return self.__altitude_boundaries

    @property
    def column_density_layers(self):
        &#34;&#34;&#34;Get the column density within each of the layers.

        Returns
        -------
        np.ndarray
            The layer column densities.

        &#34;&#34;&#34;
        return self.__column_density_layers

    @property
    def n_layers(self) -&gt; int:
        &#34;&#34;&#34;Get the number of layers in the model.

        Returns
        -------
        int
            The number of layers.

        &#34;&#34;&#34;
        return self.__n_layers

    @property
    def number_density_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the number density at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary number densities.

        &#34;&#34;&#34;
        return self.__number_density_boundaries

    @property
    def pressure_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the pressure at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary pressures.

        &#34;&#34;&#34;
        return self.__pressure_boundaries

    @property
    def temperature_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the temperature at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary temperatures.

        &#34;&#34;&#34;
        return self.__temperature_boundaries


def eos_from_array(atm: np.ndarray, altitude_boundaries: np.ndarray) \
        -&gt; ModelEquationOfState:
    &#34;&#34;&#34;Create a ModelEquationOfState from an array containing atmospheric equation
    of state variables. The array is assumed to be a 2D array, with the columns
    having the following meanings:

    0. The altitudes [km] at which the other equation of state variables are
    defined.
    1. The pressures [Pa] at the corresponding altitudes.
    2. The temperatures [K] at the corresponding altitudes.
    3. The number densities [particles / m**3] at the corresponding altitudes.

    Parameters
    ----------
    atm: np.ndarray
        2D array of atmospheric equation of state variables.
    altitude_boundaries: np.ndarray
        The desired altitudes [km] of the model boundaries.

    Returns
    -------
    ModelEquationOfState
        The modeled equation of state object.

    Raises
    ------
    FileNotFoundError
        Raised if the input file path does not exist.
    IndexError
        Raised in the input array does not have the expected shape.
    TypeError
        Raised if the input array path is not a string.
    ValueError
        Raised if the input array path does not lead to a .npy file.

    &#34;&#34;&#34;
    return ModelEquationOfState(atm[:, 0], atm[:, 1], atm[:, 2], atm[:, 3],
                                altitude_boundaries)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyRT_DISORT.eos.eos_from_array"><code class="name flex">
<span>def <span class="ident">eos_from_array</span></span>(<span>atm: numpy.ndarray, altitude_boundaries: numpy.ndarray) ‑> <a title="pyRT_DISORT.eos.ModelEquationOfState" href="#pyRT_DISORT.eos.ModelEquationOfState">ModelEquationOfState</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a ModelEquationOfState from an array containing atmospheric equation
of state variables. The array is assumed to be a 2D array, with the columns
having the following meanings:</p>
<ol>
<li>The altitudes [km] at which the other equation of state variables are
defined.</li>
<li>The pressures [Pa] at the corresponding altitudes.</li>
<li>The temperatures [K] at the corresponding altitudes.</li>
<li>The number densities [particles / m**3] at the corresponding altitudes.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atm</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>2D array of atmospheric equation of state variables.</dd>
<dt><strong><code>altitude_boundaries</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The desired altitudes [km] of the model boundaries.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pyRT_DISORT.eos.ModelEquationOfState" href="#pyRT_DISORT.eos.ModelEquationOfState">ModelEquationOfState</a></code></dt>
<dd>The modeled equation of state object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>Raised if the input file path does not exist.</dd>
<dt><code>IndexError</code></dt>
<dd>Raised in the input array does not have the expected shape.</dd>
<dt><code>TypeError</code></dt>
<dd>Raised if the input array path is not a string.</dd>
<dt><code>ValueError</code></dt>
<dd>Raised if the input array path does not lead to a .npy file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eos_from_array(atm: np.ndarray, altitude_boundaries: np.ndarray) \
        -&gt; ModelEquationOfState:
    &#34;&#34;&#34;Create a ModelEquationOfState from an array containing atmospheric equation
    of state variables. The array is assumed to be a 2D array, with the columns
    having the following meanings:

    0. The altitudes [km] at which the other equation of state variables are
    defined.
    1. The pressures [Pa] at the corresponding altitudes.
    2. The temperatures [K] at the corresponding altitudes.
    3. The number densities [particles / m**3] at the corresponding altitudes.

    Parameters
    ----------
    atm: np.ndarray
        2D array of atmospheric equation of state variables.
    altitude_boundaries: np.ndarray
        The desired altitudes [km] of the model boundaries.

    Returns
    -------
    ModelEquationOfState
        The modeled equation of state object.

    Raises
    ------
    FileNotFoundError
        Raised if the input file path does not exist.
    IndexError
        Raised in the input array does not have the expected shape.
    TypeError
        Raised if the input array path is not a string.
    ValueError
        Raised if the input array path does not lead to a .npy file.

    &#34;&#34;&#34;
    return ModelEquationOfState(atm[:, 0], atm[:, 1], atm[:, 2], atm[:, 3],
                                altitude_boundaries)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyRT_DISORT.eos.ModelEquationOfState"><code class="flex name class">
<span>class <span class="ident">ModelEquationOfState</span></span>
<span>(</span><span>altitude_grid: numpy.ndarray, pressure_grid: numpy.ndarray, temperature_grid: numpy.ndarray, number_density_grid: numpy.ndarray, altitude_boundaries: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute equation of state variables on a model grid.</p>
<p>ModelEquationOfState accepts altitudes [km], pressures [Pa],
temperatures [K], and number densities [particles / m**3], along with the
altitudes where the model is defined. It linearly interpolates
pressures and temperatures onto this new grid and assumes the ideal gas law
to calculate the number density at the new grid. It also computes the
column density within each layer using Gaussian quadrature.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>altitude_grid</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The altitudes [km] at which the equation of state variables are
defined.</dd>
<dt><strong><code>pressure_grid</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The pressures [Pa] at the corresponding altitudes.</dd>
<dt><strong><code>temperature_grid</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The temperatures [K] at the corresponding altitudes.</dd>
<dt><strong><code>number_density_grid</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The number densities [particles / m**3] at the corresponding
altitudes.</dd>
<dt><strong><code>altitude_boundaries</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The desired altitudes [km] of the model boundaries.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd>Raised if the input grids do not have the same shape.</dd>
<dt><code>TypeError</code></dt>
<dd>Raised if any of the inputs are not np.ndarrays.</dd>
<dt><code>ValueError</code></dt>
<dd>Raised if any of the inputs have unphysical values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelEquationOfState:
    &#34;&#34;&#34;Compute equation of state variables on a model grid.

    ModelEquationOfState accepts altitudes [km], pressures [Pa],
    temperatures [K], and number densities [particles / m**3], along with the
    altitudes where the model is defined. It linearly interpolates
    pressures and temperatures onto this new grid and assumes the ideal gas law
    to calculate the number density at the new grid. It also computes the
    column density within each layer using Gaussian quadrature.

    &#34;&#34;&#34;

    def __init__(self, altitude_grid: np.ndarray, pressure_grid: np.ndarray,
                 temperature_grid: np.ndarray, number_density_grid: np.ndarray,
                 altitude_boundaries: np.ndarray) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        altitude_grid: np.ndarray
            The altitudes [km] at which the equation of state variables are
            defined.
        pressure_grid: np.ndarray
            The pressures [Pa] at the corresponding altitudes.
        temperature_grid: np.ndarray
            The temperatures [K] at the corresponding altitudes.
        number_density_grid: np.ndarray
            The number densities [particles / m**3] at the corresponding
            altitudes.
        altitude_boundaries: np.ndarray
            The desired altitudes [km] of the model boundaries.

        Raises
        ------
        IndexError
            Raised if the input grids do not have the same shape.
        TypeError
            Raised if any of the inputs are not np.ndarrays.
        ValueError
            Raised if any of the inputs have unphysical values.

        &#34;&#34;&#34;
        self.__altitude_grid = altitude_grid
        self.__pressure_grid = pressure_grid
        self.__temperature_grid = temperature_grid
        self.__number_density_grid = number_density_grid
        self.__altitude_boundaries = altitude_boundaries

        self.__raise_error_if_input_variables_are_bad()
        self.__flip_grids_if_altitudes_are_mono_decreasing()

        self.__n_layers = len(self.__altitude_boundaries) - 1
        self.__pressure_boundaries = self.__make_pressure_model()
        self.__temperature_boundaries = self.__make_temperature_model()
        self.__number_density_boundaries = self.__make_number_density_model()
        self.__column_density_layers = self.__compute_column_density_layers()

    def __raise_error_if_input_variables_are_bad(self) -&gt; None:
        self.__raise_error_if_altitude_grid_is_bad()
        self.__raise_error_if_pressure_grid_is_bad()
        self.__raise_error_if_temperature_grid_is_bad()
        self.__raise_error_if_number_density_grid_is_bad()
        self.__raise_error_if_altitude_model_is_bad()
        self.__raise_index_error_if_grids_are_not_same_shape()

    def __raise_error_if_altitude_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(self.__altitude_grid, &#39;altitude_grid&#39;)

    def __raise_error_if_pressure_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(self.__pressure_grid, &#39;pressure_grid&#39;)

    def __raise_error_if_temperature_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(
            self.__temperature_grid, &#39;temperature_grid&#39;)

    def __raise_error_if_number_density_grid_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(
            self.__number_density_grid, &#39;number_density_grid&#39;)

    def __raise_index_error_if_grids_are_not_same_shape(self) -&gt; None:
        if not self.__altitude_grid.shape == self.__temperature_grid.shape == \
               self.__pressure_grid.shape == self.__number_density_grid.shape:
            raise IndexError(&#39;All input grids must have the same shape.&#39;)

    def __raise_error_if_altitude_model_is_bad(self) -&gt; None:
        self.__raise_error_if_grid_is_bad(
            self.__altitude_boundaries, &#39;altitude_boundaries&#39;)
        self.__raise_value_error_if_model_altitudes_are_not_mono_decreasing()
        self.__raise_value_error_if_too_few_layers_are_included()

    def __raise_error_if_grid_is_bad(self, array: np.ndarray, name: str) \
            -&gt; None:
        try:
            checks = self.__make_grid_checks(array)
        except TypeError:
            raise TypeError(f&#39;{name} is not a np.ndarray.&#39;) from None
        if not all(checks):
            raise ValueError(
                f&#39;{name} must be a 1D array containing positive, finite &#39;
                f&#39;values.&#39;)

    @staticmethod
    def __make_grid_checks(grid: np.ndarray) -&gt; list[bool]:
        grid_checker = ArrayChecker(grid)
        checks = [grid_checker.determine_if_array_is_1d(),
                  grid_checker.determine_if_array_is_finite(),
                  grid_checker.determine_if_array_is_non_negative()]
        return checks

    def __raise_value_error_if_model_altitudes_are_not_mono_decreasing(self) \
            -&gt; None:
        model_checker = ArrayChecker(self.__altitude_boundaries)
        if not model_checker.determine_if_array_is_monotonically_decreasing():
            raise ValueError(&#39;altitude_model must be monotonically decreasing.&#39;)

    def __raise_value_error_if_too_few_layers_are_included(self) -&gt; None:
        if len(self.__altitude_boundaries) &lt; 2:
            raise ValueError(&#39;The model must contain at least 2 boundaries &#39;
                             &#39;(i.e. one layer).&#39;)

    def __flip_grids_if_altitudes_are_mono_decreasing(self) -&gt; None:
        altitude_checker = ArrayChecker(self.__altitude_grid)
        if altitude_checker.determine_if_array_is_monotonically_decreasing():
            self.__altitude_grid = np.flip(self.__altitude_grid)
            self.__pressure_grid = np.flip(self.__pressure_grid)
            self.__temperature_grid = np.flip(self.__temperature_grid)
            self.__number_density_grid = np.flip(self.__number_density_grid)

    def __make_pressure_model(self) -&gt; np.ndarray:
        return self.__interpolate_variable_to_model_altitudes(
            self.__pressure_grid)

    def __make_temperature_model(self) -&gt; np.ndarray:
        return self.__interpolate_variable_to_model_altitudes(
            self.__temperature_grid)

    def __make_number_density_model(self) -&gt; np.ndarray:
        return self.__pressure_boundaries / \
               (Boltzmann * self.__temperature_boundaries)

    def __interpolate_variable_to_model_altitudes(self, grid: np.ndarray) \
            -&gt; np.ndarray:
        return np.interp(self.__altitude_boundaries, self.__altitude_grid, grid)

    def __compute_column_density_layers(self) -&gt; np.array:
        with warnings.catch_warnings():
            warnings.filterwarnings(&#34;ignore&#34;)
            colden = [quad(self.__make_n_at_altitude,
                           self.__altitude_boundaries[i + 1],
                           self.__altitude_boundaries[i])[0]
                      for i in range(self.__n_layers)]
            return np.array(colden)

    # TODO: This logic seems to duplicate functions above... try to fix
    def __make_n_at_altitude(self, z: float) -&gt; float:
        p = np.interp(z, self.__altitude_grid, self.__pressure_grid)
        t = np.interp(z, self.__altitude_grid, self.__temperature_grid)
        return 1 / Boltzmann * p / t

    @property
    def altitude_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the input altitudes at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary altitudes.

        &#34;&#34;&#34;
        return self.__altitude_boundaries

    @property
    def column_density_layers(self):
        &#34;&#34;&#34;Get the column density within each of the layers.

        Returns
        -------
        np.ndarray
            The layer column densities.

        &#34;&#34;&#34;
        return self.__column_density_layers

    @property
    def n_layers(self) -&gt; int:
        &#34;&#34;&#34;Get the number of layers in the model.

        Returns
        -------
        int
            The number of layers.

        &#34;&#34;&#34;
        return self.__n_layers

    @property
    def number_density_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the number density at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary number densities.

        &#34;&#34;&#34;
        return self.__number_density_boundaries

    @property
    def pressure_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the pressure at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary pressures.

        &#34;&#34;&#34;
        return self.__pressure_boundaries

    @property
    def temperature_boundaries(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the temperature at the model boundaries.

        Returns
        -------
        np.ndarray
            The boundary temperatures.

        &#34;&#34;&#34;
        return self.__temperature_boundaries</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyRT_DISORT.eos.ModelEquationOfState.altitude_boundaries"><code class="name">var <span class="ident">altitude_boundaries</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the input altitudes at the model boundaries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The boundary altitudes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def altitude_boundaries(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the input altitudes at the model boundaries.

    Returns
    -------
    np.ndarray
        The boundary altitudes.

    &#34;&#34;&#34;
    return self.__altitude_boundaries</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.eos.ModelEquationOfState.column_density_layers"><code class="name">var <span class="ident">column_density_layers</span></code></dt>
<dd>
<div class="desc"><p>Get the column density within each of the layers.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The layer column densities.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def column_density_layers(self):
    &#34;&#34;&#34;Get the column density within each of the layers.

    Returns
    -------
    np.ndarray
        The layer column densities.

    &#34;&#34;&#34;
    return self.__column_density_layers</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.eos.ModelEquationOfState.n_layers"><code class="name">var <span class="ident">n_layers</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the number of layers in the model.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of layers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_layers(self) -&gt; int:
    &#34;&#34;&#34;Get the number of layers in the model.

    Returns
    -------
    int
        The number of layers.

    &#34;&#34;&#34;
    return self.__n_layers</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.eos.ModelEquationOfState.number_density_boundaries"><code class="name">var <span class="ident">number_density_boundaries</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the number density at the model boundaries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The boundary number densities.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_density_boundaries(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the number density at the model boundaries.

    Returns
    -------
    np.ndarray
        The boundary number densities.

    &#34;&#34;&#34;
    return self.__number_density_boundaries</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.eos.ModelEquationOfState.pressure_boundaries"><code class="name">var <span class="ident">pressure_boundaries</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the pressure at the model boundaries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The boundary pressures.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pressure_boundaries(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the pressure at the model boundaries.

    Returns
    -------
    np.ndarray
        The boundary pressures.

    &#34;&#34;&#34;
    return self.__pressure_boundaries</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.eos.ModelEquationOfState.temperature_boundaries"><code class="name">var <span class="ident">temperature_boundaries</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the temperature at the model boundaries.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The boundary temperatures.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def temperature_boundaries(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the temperature at the model boundaries.

    Returns
    -------
    np.ndarray
        The boundary temperatures.

    &#34;&#34;&#34;
    return self.__temperature_boundaries</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyRT_DISORT" href="index.html">pyRT_DISORT</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyRT_DISORT.eos.eos_from_array" href="#pyRT_DISORT.eos.eos_from_array">eos_from_array</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyRT_DISORT.eos.ModelEquationOfState" href="#pyRT_DISORT.eos.ModelEquationOfState">ModelEquationOfState</a></code></h4>
<ul class="">
<li><code><a title="pyRT_DISORT.eos.ModelEquationOfState.altitude_boundaries" href="#pyRT_DISORT.eos.ModelEquationOfState.altitude_boundaries">altitude_boundaries</a></code></li>
<li><code><a title="pyRT_DISORT.eos.ModelEquationOfState.column_density_layers" href="#pyRT_DISORT.eos.ModelEquationOfState.column_density_layers">column_density_layers</a></code></li>
<li><code><a title="pyRT_DISORT.eos.ModelEquationOfState.n_layers" href="#pyRT_DISORT.eos.ModelEquationOfState.n_layers">n_layers</a></code></li>
<li><code><a title="pyRT_DISORT.eos.ModelEquationOfState.number_density_boundaries" href="#pyRT_DISORT.eos.ModelEquationOfState.number_density_boundaries">number_density_boundaries</a></code></li>
<li><code><a title="pyRT_DISORT.eos.ModelEquationOfState.pressure_boundaries" href="#pyRT_DISORT.eos.ModelEquationOfState.pressure_boundaries">pressure_boundaries</a></code></li>
<li><code><a title="pyRT_DISORT.eos.ModelEquationOfState.temperature_boundaries" href="#pyRT_DISORT.eos.ModelEquationOfState.temperature_boundaries">temperature_boundaries</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>