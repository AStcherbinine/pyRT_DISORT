<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyRT_DISORT.controller API documentation</title>
<meta name="description" content="The controller module holds miscellaneous classes responsible for creating
arrays that control how DISORT runs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyRT_DISORT.controller</code></h1>
</header>
<section id="section-intro">
<p>The controller module holds miscellaneous classes responsible for creating
arrays that control how DISORT runs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The controller module holds miscellaneous classes responsible for creating
arrays that control how DISORT runs.
&#34;&#34;&#34;
from warnings import warn
import numpy as np


class ComputationalParameters:
    &#34;&#34;&#34;Create a data structure for holding the size of computational parameters.

    ComputationalParameters holds the number of model layers, streams, moments,
    and angles. It also performs basic checks that these values are plausible.
    Objects of this class are meant to be be used as inputs to other classes.

    &#34;&#34;&#34;

    # TODO: I&#39;d like a better description of n_user_levels. It&#39;s not documented
    #  in the DISORT documentation...
    def __init__(self, n_layers: int, n_moments: int, n_streams: int,
                 n_azimuth: int, n_polar: int, n_user_levels: int) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        n_layers: int
            The number of layers to use in the model.
        n_moments: int
            The number of polynomial moments to use in the model. This number
            should be greater than or equal to &#39;n_streams&#39; in problems with
            scattering. In problems without scattering, this variable is not
            used by DISORT.
        n_streams: int
            The number of streams (i.e. the number of computational polar
            angles) to use in the model. This number should be even and at least
            2. In general, the more streams used the more accurate DISORT&#39;s
            computations will be.
        n_azimuth: int
            The number of azimuthal angles where DISORT should return radiant
            quantities.
        n_polar: int
            The number of user-specified polar angles where DISORT should return
            radiant quantities. Only used by DISORT if user_angles (from
            ModelBehavior) == True.
        n_user_levels: int
            The number of user levels to use in the model.

        Raises
        ------
        TypeError
            Raised if any of the inputs cannot be converted to an int.
        ValueError
            Raised if any of the inputs are not positive finite.

        Warnings
        --------
        UserWarning
            Raised if n_streams is not even or if n_streams is greater than
            n_moments.

        &#34;&#34;&#34;
        self.__n_layers = self.__make_n_layers(n_layers)
        self.__n_moments = self.__make_n_moments(n_moments)
        self.__n_streams = self.__make_n_streams(n_streams)
        self.__n_azimuth = self.__make_n_azimuth(n_azimuth)
        self.__n_polar = self.__make_n_polar(n_polar)
        self.__n_user_levels = self.__make_n_user_levels(n_user_levels)

        self.__warn_if_n_streams_is_not_even()
        self.__warn_if_n_streams_is_greater_than_n_moments()

    def __make_n_layers(self, n_layers: int) -&gt; int:
        n_layers = self.__make_parameter(n_layers, &#39;n_layers&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_layers, &#39;n_layers&#39;)
        return n_layers

    def __make_n_moments(self, n_moments: int) -&gt; int:
        n_moments = self.__make_parameter(n_moments, &#39;n_moments&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_moments, &#39;n_moments&#39;)
        return n_moments

    def __make_n_streams(self, n_streams: int) -&gt; int:
        n_streams = self.__make_parameter(n_streams, &#39;n_streams&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_streams, &#39;n_streams&#39;)
        return n_streams

    def __make_n_azimuth(self, n_azimuth: int) -&gt; int:
        n_azimuth = self.__make_parameter(n_azimuth, &#39;n_azimuth&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_azimuth, &#39;n_azimuth&#39;)
        return n_azimuth

    def __make_n_polar(self, n_polar: int) -&gt; int:
        n_polar = self.__make_parameter(n_polar, &#39;n_polar&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_polar, &#39;n_polar&#39;)
        return n_polar

    def __make_n_user_levels(self, n_user_levels: int) -&gt; int:
        n_user_levels = self.__make_parameter(n_user_levels, &#39;n_user_levels&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_user_levels, &#39;n_user_levels&#39;)
        return n_user_levels

    @staticmethod
    def __make_parameter(param: int, name: str) -&gt; int:
        try:
            return int(param)
        except TypeError as te:
            raise TypeError(f&#39;Cannot convert {name} to an int.&#39;) from te
        except ValueError as ve:
            raise ValueError(f&#39;Cannot convert {name} to an int.&#39;) from ve
        except OverflowError as oe:
            raise ValueError(f&#39;{name} must be finite.&#39;) from oe

    @staticmethod
    def __raise_value_error_if_parameter_is_not_positive(
            param: int, name: str) -&gt; None:
        if param &lt; 1:
            raise ValueError(f&#39;{name} must be positive.&#39;)

    def __warn_if_n_streams_is_not_even(self) -&gt; None:
        if self.__n_streams % 2 != 0:
            warn(&#39;n_streams should be even.&#39;)

    def __warn_if_n_streams_is_greater_than_n_moments(self) -&gt; None:
        if self.__n_streams &gt; self.__n_moments:
            warn(&#39;n_streams should not be greater than n_moments.&#39;)

    @property
    def n_layers(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of layers.

        Returns
        -------
        int
            The number of layers.

        &#34;&#34;&#34;
        return self.__n_layers

    @property
    def n_moments(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of moments.

        Returns
        -------
        int
            The number of moments.

        &#34;&#34;&#34;
        return self.__n_moments

    @property
    def n_streams(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of streams.

        Returns
        -------
        int
            The number of streams.

        &#34;&#34;&#34;
        return self.__n_streams

    @property
    def n_azimuth(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of azimuthal angles.

        Returns
        -------
        int
            The number of azimuthal angles.

        &#34;&#34;&#34;
        return self.__n_azimuth

    @property
    def n_polar(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of user_specified polar angles.

        Returns
        -------
        int
            The number of polar angles.

        &#34;&#34;&#34;
        return self.__n_polar

    @property
    def n_user_levels(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of user levels.

        Returns
        -------
        int
            The number of user levels.

        &#34;&#34;&#34;
        return self.__n_user_levels


# TODO: fix user_angles docstring. It&#39;s a mess
class ModelBehavior:
    &#34;&#34;&#34;Create a data structure for holding the DISORT control variables.

    ModelBehavior holds the control flags that dictate DISORT&#39;s behavior. It
    also performs basic checks that the input control options are plausible.

    &#34;&#34;&#34;
    def __init__(self, accuracy: float = 0.0, delta_m_plus: bool = False,
                 do_pseudo_sphere: bool = False, header: str = &#39;&#39;,
                 incidence_beam_conditions: bool = False,
                 only_fluxes: bool = False, print_variables: list[bool] = None,
                 radius: float = 6371.0, user_angles: bool = True,
                 user_optical_depths: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        accuracy: float, optional
            The convergence criterion for azimuthal (Fourier cosine) series.
            Will stop when the following occurs twice: largest term being added
            is less than &#39;accuracy&#39; times total series sum (twice because
            there are cases where terms are anomalously small but azimuthal
            series has not converged). Should be between 0 and 0.01 to avoid
            risk of serious non-convergence. Has no effect on problems lacking a
            beam source, since azimuthal series has only one term in that case.
            Default is 0.0.
        delta_m_plus: bool, optional
            Denote whether to use the delta-M+ method of Lin et al. (2018).
            Default is False.
        do_pseudo_sphere: bool, optional
            Denote whether to use a pseudo-spherical correction. Default is
            False.
        header: str, optional
            Use a 127- (or less) character header for prints, embedded in the
            DISORT banner. Input headers greater than 127 characters will be
            truncated. Setting header=&#39;&#39; will eliminate both the banner and the
            header, and this is the only way to do so (&#39;header&#39; is not
            controlled by any of the &#39;print&#39; flags); &#39;header&#39; can be used
            to mark the progress of a calculation in which DISORT is called many
            times, while leaving all other printing turned off. Default is &#39;&#39;.
        incidence_beam_conditions: bool, optional
            Denote what functions of the incidence beam angle should be
            included. If True, return the albedo and transmissivity of the
            entire medium as a function of incidence beam angle. In this case,
            the following inputs are the only ones considered by DISORT:

                - n_layers (from ComputationalParameters)
                - DTAUC
                - SSALB
                - PMOM
                - n_streams (from ComputationalParameters)
                - user_angles (from this class)
                - n_polar (from ComputationalParameters)
                - UMU
                - ALBEDO
                - print_variables (from this class)
                - header (from this class)

            PLANK is assumed to be False, LAMBER is assumed to be True, and
            ONLYFL must be False. The only output is ALBMED and TRNMED. The
            intensities are not corrected for delta-M+ correction.

            If False, this is accommodates any general case of boundary
            conditions including beam illumination from the top, isotropic
            illumination from the top, thermal emission from the top, internal
            thermal emission, reflection at the bottom, and/or thermal emission
            from the bottom. Default is False.
        only_fluxes: bool, optional
            Determine if only the fluxes are returned by the model. If True,
            return fluxes, flux divergences, and mean intensities; if False,
            return all those quantities and intensities. In addition, if True
            the number of polar angles can be 0, the number of azimuthal angles
            can be 0, phi is not used, and all values of intensity (UU) will be
            set to 0 (these are defined in ComputationalParameters). Default is
            False.
        print_variables: list[bool], optional
            Make a list of variables that control what DISORT prints. The 5
            booleans control whether each of the following is printed:

            1. Input variables (except PMOM)
            2. Fluxes
            3. Intensities at user levels and angles
            4. Planar transmissivity and planar albedo as a function of solar
            zenith angle (incidence_beam_conditions == True)
            5. PMOM for each layer (but only if 1. == True and only for layers
            with scattering)

            Default is None, which makes [False, False, False, False, False].
        radius: float, optional
            The planetary radius. This is presumably only used if
            do_pseudo_sphere == True, although there is no documentation on
            this. Default is 6371.0.
        user_angles: bool, optional
            Denote whether radiant quantities should be returned at user angles.
            If False, radiant quantities are to be returned at computational
            polar angles. Also, UMU will return the cosines of the computational
            polar angles and n_polar (from ComputationalParameters) will return
            their number ( = n_streams).UMU must
            be large enough to contain n_streams elements. If True,
            radiant quantities are to be returned at user-specified polar
            angles, as follows: NUMU No. of polar angles (zero is a legal value
            only when &#39;only_fluxes&#39; == True ) UMU(IU) IU=1 to NUMU, cosines of
            output polar angles in increasing order---starting with negative
            (downward) values (if any) and on through positive (upward)
            values; *** MUST NOT HAVE ANY ZERO VALUES ***. Default is True.
        user_optical_depths: bool, optional
            Denote whether radiant quantities are returned at user-specified
            optical depths. Default is False.

        Raises
        ------
        TypeError
            Raised if any inputs cannot be cast to the correct type.
        ValueError
            Raised if any inputs cannot be cast to the correct type or if
            print_variables does not have 5 elements.

        Warnings
        --------
        UserWarning
            Raised if accuracy is not between 0 and 0.01.

        &#34;&#34;&#34;
        self.__accuracy = self.__make_accuracy(accuracy)
        self.__delta_m_plus = self.__make_delta_m_plus(delta_m_plus)
        self.__do_pseudo_sphere = self.__make_do_pseudo_sphere(do_pseudo_sphere)
        self.__header = self.__make_header(header)
        self.__incidence_beam_conditions = \
            self.__make_incidence_beam_conditions(incidence_beam_conditions)
        self.__only_fluxes = self.__make_only_fluxes(only_fluxes)
        self.__print_variables = self.__make_print_variables(print_variables)
        self.__radius = self.__make_radius(radius)
        self.__user_angles = self.__make_user_angles(user_angles)
        self.__user_optical_depths = self.__make_user_optical_depths(
            user_optical_depths)

        self.__warn_if_accuracy_is_outside_valid_range()

    def __make_accuracy(self, accuracy: float) -&gt; float:
        return self.__cast_variable_to_float(accuracy, &#39;accuracy&#39;)

    def __make_delta_m_plus(self, delta_m_plus: bool) -&gt; bool:
        return self.__cast_variable_to_bool(delta_m_plus, &#39;delta_m_plus&#39;)

    def __make_do_pseudo_sphere(self, do_pseudo_sphere: bool) -&gt; bool:
        return self.__cast_variable_to_bool(
            do_pseudo_sphere, &#39;do_pseudo_sphere&#39;)

    # TODO: this does more than one thing
    @staticmethod
    def __make_header(header) -&gt; str:
        try:
            header = str(header)
            if len(header) &gt;= 127:
                header = header[:126]
            return header
        except TypeError as te:
            raise TypeError(&#39;header cannot be cast into a string.&#39;) from te

    def __make_incidence_beam_conditions(self, ibcnd: bool) -&gt; bool:
        return self.__cast_variable_to_bool(ibcnd, &#39;incidence_beam_conditions&#39;)

    def __make_only_fluxes(self, only_fluxes: bool) -&gt; bool:
        return self.__cast_variable_to_bool(only_fluxes, &#39;only_fluxes&#39;)

    # TODO: this does more than one thing
    @staticmethod
    def __make_print_variables(pvar) -&gt; list[bool]:
        if pvar is None:
            return [False, False, False, False, False]
        else:
            try:
                prnt = [bool(f) for f in pvar]
                if len(prnt) != 5:
                    raise ValueError(&#39;print_variables should have 5 elements.&#39;)
                return prnt
            except TypeError as te:
                raise TypeError(&#39;print_variables should be a list of bools&#39;) \
                    from te

    def __make_radius(self, radius: float) -&gt; float:
        radius = self.__cast_variable_to_float(radius, &#39;radius&#39;)
        self.__raise_value_error_if_radius_is_not_positive(radius)
        return radius

    def __make_user_angles(self, user_angles: bool) -&gt; bool:
        return self.__cast_variable_to_bool(user_angles, &#39;user_angles&#39;)

    def __make_user_optical_depths(self, user_optical_depths: bool) -&gt; bool:
        return self.__cast_variable_to_bool(
            user_optical_depths, &#39;user_optical_depths&#39;)

    @staticmethod
    def __cast_variable_to_float(variable: float, name: str) -&gt; float:
        try:
            return float(variable)
        except TypeError as te:
            raise TypeError(f&#39;{name} cannot be cast into a float.&#39;) from te
        except ValueError as ve:
            raise ValueError(f&#39;{name} cannot be cast into a float.&#39;) from ve

    @staticmethod
    def __cast_variable_to_bool(variable: bool, name: str) -&gt; bool:
        try:
            return bool(variable)
        except TypeError as te:
            raise TypeError(f&#39;{name} cannot be cast into a boolean.&#39;) from te

    @staticmethod
    def __raise_value_error_if_radius_is_not_positive(radius) -&gt; None:
        if radius &lt;= 0:
            raise ValueError(&#39;radius must be positive.&#39;)

    def __warn_if_accuracy_is_outside_valid_range(self) -&gt; None:
        if not 0 &lt;= self.__accuracy &lt;= 0.01:
            warn(&#39;accuracy is expected to be between 0 and 0.01.&#39;)

    @property
    def accuracy(self) -&gt; float:
        &#34;&#34;&#34;Get the input accuracy.

        Returns
        -------
        float
            The accuracy.

        Notes
        -----
        In DISORT, this variable is named &#34;ACCUR&#34;.

        &#34;&#34;&#34;
        return self.__accuracy

    @property
    def delta_m_plus(self) -&gt; bool:
        &#34;&#34;&#34;Get whether to use delta-M+ scaling.

        Returns
        -------
        bool
            True if delta-M+ scaling is requested; False otherwise.

        Notes
        -----
        In DISORT, this variable is named &#34;DELTAMPLUS&#34;. There is no
        documentation on this variable.

        &#34;&#34;&#34;
        return self.__delta_m_plus

    @property
    def do_pseudo_sphere(self) -&gt; bool:
        &#34;&#34;&#34;Get whether to perform a pseudo-spherical correction.

        Returns
        -------
        bool
            True if a pseudo-spherical correction is requested; False otherwise.

        Notes
        -----
        In DISORT, this variable is named &#34;DO_PSEUDO_SPHERE&#34;. There is no
        documentation on this variable.

        &#34;&#34;&#34;
        return self.__do_pseudo_sphere

    @property
    def header(self) -&gt; str:
        &#34;&#34;&#34;Get the characters that will appear in the DISORT banner.

        Returns
        -------
        str
            The characters in the DISORT banner.

        Notes
        -----
        In DISORT, this variable is named &#34;HEADER&#34;.

        &#34;&#34;&#34;
        return self.__header

    @property
    def incidence_beam_conditions(self) -&gt; bool:
        &#34;&#34;&#34;Get whether the model will only return albedo and transmissivity.

        Returns
        -------
        bool
            True if DISORT should only return albedo and transmissivity; False
            otherwise.

        &#34;&#34;&#34;
        return self.__incidence_beam_conditions

    @property
    def only_fluxes(self) -&gt; bool:
        &#34;&#34;&#34;Get whether DISORT should only return fluxes.

        Returns
        -------
        bool
            True if only fluxes are requested; False if fluxes and intensities
            are requested.

        Notes
        -----
        In DISORT, this variable is named &#34;ONLYFL&#34;.

        &#34;&#34;&#34;
        return self.__only_fluxes

    @property
    def print_variables(self) -&gt; list[bool]:
        &#34;&#34;&#34;Get the variables to print.

        Returns
        -------
        list[bool]
            The variables to print

        Notes
        -----
        In DISORT, this variable is named &#34;PRNT&#34;.

        &#34;&#34;&#34;
        return self.__print_variables

    @property
    def radius(self) -&gt; float:
        &#34;&#34;&#34;Get the planetary radius.

        Returns
        -------
        float
            The planetary radius.

        Notes
        -----
        In DISORT, this variable is named &#34;EARTH_RADIUS&#34;. There is no
        documentation on this variable, though I&#39;m presuming it could be any
        planetary radius.

        &#34;&#34;&#34;
        return self.__radius

    @property
    def user_angles(self) -&gt; bool:
        &#34;&#34;&#34;Get whether radiant quantities should be returned at user angles.

        Returns
        -------
        bool
            True if quantities are returned at user-specified angles; False if
            they are returned at computational polar angles.

        Notes
        -----
        In DISORT, this variable is named &#34;USRANG&#34;.

        &#34;&#34;&#34;
        return self.__user_angles

    @property
    def user_optical_depths(self) -&gt; bool:
        &#34;&#34;&#34;Get whether radiant quantities should be returned at user optical
        depths.

        Returns
        -------
        bool
            True if quantities are returned at user optical depths; False if
            they are returned at the boundary of every computational layer.

        Notes
        -----
        In DISORT, this variable is named &#34;USRTAU&#34;.

        &#34;&#34;&#34;
        return self.__user_optical_depths


class OutputArrays:
    &#34;&#34;&#34;Create a data structure to make the DISORT output arrays.

    OutputArrays creates arrays of 0s that are designed to get populated with
    values as DISORT runs.

    &#34;&#34;&#34;

    def __init__(self, computational_params: ComputationalParameters) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        computational_params: ComputationalParameters
            Data structure holding the model computational variables.

        Raises
        ------
        TypeError
            Raised if input is not an instance of ComputationalParameters.

        &#34;&#34;&#34;
        self.__cp = computational_params

        self.__raise_type_error_if_input_is_not_cp()

        self.__albedo_medium = self.__make_albedo_medium()
        self.__diffuse_up_flux = self.__make_diffuse_up_flux()
        self.__diffuse_down_flux = self.__make_diffuse_down_flux()
        self.__direct_beam_flux = self.__make_direct_beam_flux()
        self.__flux_divergence = self.__make_flux_divergence()
        self.__intensity = self.__make_intensity()
        self.__mean_intensity = self.__make_mean_intensity()
        self.__transmissivity_medium = self.__make_transmissivity_medium()

    def __raise_type_error_if_input_is_not_cp(self) -&gt; None:
        if not isinstance(self.__cp, ComputationalParameters):
            raise TypeError(&#39;computational_params must be an instance of &#39;
                            &#39;ComputationalParameters.&#39;)

    def __make_albedo_medium(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_polar)

    def __make_diffuse_up_flux(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_diffuse_down_flux(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_direct_beam_flux(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_flux_divergence(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_intensity(self) -&gt; np.ndarray:
        return np.zeros((self.__cp.n_polar, self.__cp.n_user_levels,
                         self.__cp.n_azimuth))

    def __make_mean_intensity(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_transmissivity_medium(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_polar)

    @property
    def albedo_medium(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the albedo of the medium output array.

        Returns
        -------
        np.ndarray
            The albedo of the medium.

        Notes
        -----
        In DISORT, this variable is named &#34;ALBMED&#34;.

        &#34;&#34;&#34;
        return self.__albedo_medium

    @property
    def diffuse_up_flux(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the diffuse upward flux output array.

        Returns
        -------
        np.ndarray
            The diffuse upward flux.

        Notes
        -----
        In DISORT, this variable is named &#34;FLUP&#34;.

        &#34;&#34;&#34;
        return self.__diffuse_up_flux

    @property
    def diffuse_down_flux(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the diffuse downward flux output array, which will be the total
        downward flux minus the direct beam flux.

        Returns
        -------
        np.ndarray
            The diffuse downward flux.

        Notes
        -----
        In DISORT, this variable is named &#34;RFLDN&#34;.

        &#34;&#34;&#34;
        return self.__diffuse_down_flux

    @property
    def direct_beam_flux(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the direct beam flux output array.

        Returns
        -------
        np.ndarray
            The direct beam flux.

        Notes
        -----
        In DISORT, this variable is named &#34;RFLDIR&#34;.

        &#34;&#34;&#34;
        return self.__direct_beam_flux

    @property
    def flux_divergence(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the flux divergence output array, which is will represent
        (d(net_flux) / d(optical_depth)). This is an exact result.

        Returns
        -------
        np.ndarray
            The flux divergence.

        Notes
        -----
        In DISORT, this variable is named &#34;DFDT&#34;.

        &#34;&#34;&#34;
        return self.__flux_divergence

    @property
    def intensity(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the intensity output array.

        Returns
        -------
        np.ndarray
            The intensity.

        Notes
        -----
        In DISORT, this variable is named &#34;UU&#34;.

        &#34;&#34;&#34;
        return self.__intensity

    @property
    def mean_intensity(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the mean intensity output array.

        Returns
        -------
        np.ndarray
            The mean intensity.

        Notes
        -----
        In DISORT, this variable is named &#34;UAVG&#34;.

        &#34;&#34;&#34;
        return self.__mean_intensity

    @property
    def transmissivity_medium(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the transmissivity of the medium output array.

        Returns
        -------
        np.ndarray
            The transmissivity of the medium.

        Notes
        -----
        In DISORT, this variable is named &#34;TRNMED&#34;.

        &#34;&#34;&#34;
        return self.__transmissivity_medium</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyRT_DISORT.controller.ComputationalParameters"><code class="flex name class">
<span>class <span class="ident">ComputationalParameters</span></span>
<span>(</span><span>n_layers: int, n_moments: int, n_streams: int, n_azimuth: int, n_polar: int, n_user_levels: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a data structure for holding the size of computational parameters.</p>
<p>ComputationalParameters holds the number of model layers, streams, moments,
and angles. It also performs basic checks that these values are plausible.
Objects of this class are meant to be be used as inputs to other classes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_layers</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of layers to use in the model.</dd>
<dt><strong><code>n_moments</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of polynomial moments to use in the model. This number
should be greater than or equal to 'n_streams' in problems with
scattering. In problems without scattering, this variable is not
used by DISORT.</dd>
<dt><strong><code>n_streams</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of streams (i.e. the number of computational polar
angles) to use in the model. This number should be even and at least
2. In general, the more streams used the more accurate DISORT's
computations will be.</dd>
<dt><strong><code>n_azimuth</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of azimuthal angles where DISORT should return radiant
quantities.</dd>
<dt><strong><code>n_polar</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of user-specified polar angles where DISORT should return
radiant quantities. Only used by DISORT if user_angles (from
ModelBehavior) == True.</dd>
<dt><strong><code>n_user_levels</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of user levels to use in the model.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised if any of the inputs cannot be converted to an int.</dd>
<dt><code>ValueError</code></dt>
<dd>Raised if any of the inputs are not positive finite.</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<p>UserWarning
Raised if n_streams is not even or if n_streams is greater than
n_moments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComputationalParameters:
    &#34;&#34;&#34;Create a data structure for holding the size of computational parameters.

    ComputationalParameters holds the number of model layers, streams, moments,
    and angles. It also performs basic checks that these values are plausible.
    Objects of this class are meant to be be used as inputs to other classes.

    &#34;&#34;&#34;

    # TODO: I&#39;d like a better description of n_user_levels. It&#39;s not documented
    #  in the DISORT documentation...
    def __init__(self, n_layers: int, n_moments: int, n_streams: int,
                 n_azimuth: int, n_polar: int, n_user_levels: int) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        n_layers: int
            The number of layers to use in the model.
        n_moments: int
            The number of polynomial moments to use in the model. This number
            should be greater than or equal to &#39;n_streams&#39; in problems with
            scattering. In problems without scattering, this variable is not
            used by DISORT.
        n_streams: int
            The number of streams (i.e. the number of computational polar
            angles) to use in the model. This number should be even and at least
            2. In general, the more streams used the more accurate DISORT&#39;s
            computations will be.
        n_azimuth: int
            The number of azimuthal angles where DISORT should return radiant
            quantities.
        n_polar: int
            The number of user-specified polar angles where DISORT should return
            radiant quantities. Only used by DISORT if user_angles (from
            ModelBehavior) == True.
        n_user_levels: int
            The number of user levels to use in the model.

        Raises
        ------
        TypeError
            Raised if any of the inputs cannot be converted to an int.
        ValueError
            Raised if any of the inputs are not positive finite.

        Warnings
        --------
        UserWarning
            Raised if n_streams is not even or if n_streams is greater than
            n_moments.

        &#34;&#34;&#34;
        self.__n_layers = self.__make_n_layers(n_layers)
        self.__n_moments = self.__make_n_moments(n_moments)
        self.__n_streams = self.__make_n_streams(n_streams)
        self.__n_azimuth = self.__make_n_azimuth(n_azimuth)
        self.__n_polar = self.__make_n_polar(n_polar)
        self.__n_user_levels = self.__make_n_user_levels(n_user_levels)

        self.__warn_if_n_streams_is_not_even()
        self.__warn_if_n_streams_is_greater_than_n_moments()

    def __make_n_layers(self, n_layers: int) -&gt; int:
        n_layers = self.__make_parameter(n_layers, &#39;n_layers&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_layers, &#39;n_layers&#39;)
        return n_layers

    def __make_n_moments(self, n_moments: int) -&gt; int:
        n_moments = self.__make_parameter(n_moments, &#39;n_moments&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_moments, &#39;n_moments&#39;)
        return n_moments

    def __make_n_streams(self, n_streams: int) -&gt; int:
        n_streams = self.__make_parameter(n_streams, &#39;n_streams&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_streams, &#39;n_streams&#39;)
        return n_streams

    def __make_n_azimuth(self, n_azimuth: int) -&gt; int:
        n_azimuth = self.__make_parameter(n_azimuth, &#39;n_azimuth&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_azimuth, &#39;n_azimuth&#39;)
        return n_azimuth

    def __make_n_polar(self, n_polar: int) -&gt; int:
        n_polar = self.__make_parameter(n_polar, &#39;n_polar&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_polar, &#39;n_polar&#39;)
        return n_polar

    def __make_n_user_levels(self, n_user_levels: int) -&gt; int:
        n_user_levels = self.__make_parameter(n_user_levels, &#39;n_user_levels&#39;)
        self.__raise_value_error_if_parameter_is_not_positive(
            n_user_levels, &#39;n_user_levels&#39;)
        return n_user_levels

    @staticmethod
    def __make_parameter(param: int, name: str) -&gt; int:
        try:
            return int(param)
        except TypeError as te:
            raise TypeError(f&#39;Cannot convert {name} to an int.&#39;) from te
        except ValueError as ve:
            raise ValueError(f&#39;Cannot convert {name} to an int.&#39;) from ve
        except OverflowError as oe:
            raise ValueError(f&#39;{name} must be finite.&#39;) from oe

    @staticmethod
    def __raise_value_error_if_parameter_is_not_positive(
            param: int, name: str) -&gt; None:
        if param &lt; 1:
            raise ValueError(f&#39;{name} must be positive.&#39;)

    def __warn_if_n_streams_is_not_even(self) -&gt; None:
        if self.__n_streams % 2 != 0:
            warn(&#39;n_streams should be even.&#39;)

    def __warn_if_n_streams_is_greater_than_n_moments(self) -&gt; None:
        if self.__n_streams &gt; self.__n_moments:
            warn(&#39;n_streams should not be greater than n_moments.&#39;)

    @property
    def n_layers(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of layers.

        Returns
        -------
        int
            The number of layers.

        &#34;&#34;&#34;
        return self.__n_layers

    @property
    def n_moments(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of moments.

        Returns
        -------
        int
            The number of moments.

        &#34;&#34;&#34;
        return self.__n_moments

    @property
    def n_streams(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of streams.

        Returns
        -------
        int
            The number of streams.

        &#34;&#34;&#34;
        return self.__n_streams

    @property
    def n_azimuth(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of azimuthal angles.

        Returns
        -------
        int
            The number of azimuthal angles.

        &#34;&#34;&#34;
        return self.__n_azimuth

    @property
    def n_polar(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of user_specified polar angles.

        Returns
        -------
        int
            The number of polar angles.

        &#34;&#34;&#34;
        return self.__n_polar

    @property
    def n_user_levels(self) -&gt; int:
        &#34;&#34;&#34;Get the input number of user levels.

        Returns
        -------
        int
            The number of user levels.

        &#34;&#34;&#34;
        return self.__n_user_levels</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyRT_DISORT.controller.ComputationalParameters.n_azimuth"><code class="name">var <span class="ident">n_azimuth</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the input number of azimuthal angles.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of azimuthal angles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_azimuth(self) -&gt; int:
    &#34;&#34;&#34;Get the input number of azimuthal angles.

    Returns
    -------
    int
        The number of azimuthal angles.

    &#34;&#34;&#34;
    return self.__n_azimuth</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ComputationalParameters.n_layers"><code class="name">var <span class="ident">n_layers</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the input number of layers.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of layers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_layers(self) -&gt; int:
    &#34;&#34;&#34;Get the input number of layers.

    Returns
    -------
    int
        The number of layers.

    &#34;&#34;&#34;
    return self.__n_layers</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ComputationalParameters.n_moments"><code class="name">var <span class="ident">n_moments</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the input number of moments.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of moments.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_moments(self) -&gt; int:
    &#34;&#34;&#34;Get the input number of moments.

    Returns
    -------
    int
        The number of moments.

    &#34;&#34;&#34;
    return self.__n_moments</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ComputationalParameters.n_polar"><code class="name">var <span class="ident">n_polar</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the input number of user_specified polar angles.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of polar angles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_polar(self) -&gt; int:
    &#34;&#34;&#34;Get the input number of user_specified polar angles.

    Returns
    -------
    int
        The number of polar angles.

    &#34;&#34;&#34;
    return self.__n_polar</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ComputationalParameters.n_streams"><code class="name">var <span class="ident">n_streams</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the input number of streams.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of streams.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_streams(self) -&gt; int:
    &#34;&#34;&#34;Get the input number of streams.

    Returns
    -------
    int
        The number of streams.

    &#34;&#34;&#34;
    return self.__n_streams</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ComputationalParameters.n_user_levels"><code class="name">var <span class="ident">n_user_levels</span> : int</code></dt>
<dd>
<div class="desc"><p>Get the input number of user levels.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of user levels.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_user_levels(self) -&gt; int:
    &#34;&#34;&#34;Get the input number of user levels.

    Returns
    -------
    int
        The number of user levels.

    &#34;&#34;&#34;
    return self.__n_user_levels</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior"><code class="flex name class">
<span>class <span class="ident">ModelBehavior</span></span>
<span>(</span><span>accuracy: float = 0.0, delta_m_plus: bool = False, do_pseudo_sphere: bool = False, header: str = '', incidence_beam_conditions: bool = False, only_fluxes: bool = False, print_variables: list = None, radius: float = 6371.0, user_angles: bool = True, user_optical_depths: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a data structure for holding the DISORT control variables.</p>
<p>ModelBehavior holds the control flags that dictate DISORT's behavior. It
also performs basic checks that the input control options are plausible.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>accuracy</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The convergence criterion for azimuthal (Fourier cosine) series.
Will stop when the following occurs twice: largest term being added
is less than 'accuracy' times total series sum (twice because
there are cases where terms are anomalously small but azimuthal
series has not converged). Should be between 0 and 0.01 to avoid
risk of serious non-convergence. Has no effect on problems lacking a
beam source, since azimuthal series has only one term in that case.
Default is 0.0.</dd>
<dt><strong><code>delta_m_plus</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Denote whether to use the delta-M+ method of Lin et al. (2018).
Default is False.</dd>
<dt><strong><code>do_pseudo_sphere</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Denote whether to use a pseudo-spherical correction. Default is
False.</dd>
<dt><strong><code>header</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Use a 127- (or less) character header for prints, embedded in the
DISORT banner. Input headers greater than 127 characters will be
truncated. Setting header='' will eliminate both the banner and the
header, and this is the only way to do so ('header' is not
controlled by any of the 'print' flags); 'header' can be used
to mark the progress of a calculation in which DISORT is called many
times, while leaving all other printing turned off. Default is ''.</dd>
<dt><strong><code>incidence_beam_conditions</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>
<p>Denote what functions of the incidence beam angle should be
included. If True, return the albedo and transmissivity of the
entire medium as a function of incidence beam angle. In this case,
the following inputs are the only ones considered by DISORT:</p>
<pre><code>- n_layers (from ComputationalParameters)
- DTAUC
- SSALB
- PMOM
- n_streams (from ComputationalParameters)
- user_angles (from this class)
- n_polar (from ComputationalParameters)
- UMU
- ALBEDO
- print_variables (from this class)
- header (from this class)
</code></pre>
<p>PLANK is assumed to be False, LAMBER is assumed to be True, and
ONLYFL must be False. The only output is ALBMED and TRNMED. The
intensities are not corrected for delta-M+ correction.</p>
<p>If False, this is accommodates any general case of boundary
conditions including beam illumination from the top, isotropic
illumination from the top, thermal emission from the top, internal
thermal emission, reflection at the bottom, and/or thermal emission
from the bottom. Default is False.</p>
</dd>
<dt><strong><code>only_fluxes</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determine if only the fluxes are returned by the model. If True,
return fluxes, flux divergences, and mean intensities; if False,
return all those quantities and intensities. In addition, if True
the number of polar angles can be 0, the number of azimuthal angles
can be 0, phi is not used, and all values of intensity (UU) will be
set to 0 (these are defined in ComputationalParameters). Default is
False.</dd>
<dt><strong><code>print_variables</code></strong> :&ensp;<code>list[bool]</code>, optional</dt>
<dd>
<p>Make a list of variables that control what DISORT prints. The 5
booleans control whether each of the following is printed:</p>
<ol>
<li>Input variables (except PMOM)</li>
<li>Fluxes</li>
<li>Intensities at user levels and angles</li>
<li>Planar transmissivity and planar albedo as a function of solar
zenith angle (incidence_beam_conditions == True)</li>
<li>PMOM for each layer (but only if 1. == True and only for layers
with scattering)</li>
</ol>
<p>Default is None, which makes [False, False, False, False, False].</p>
</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The planetary radius. This is presumably only used if
do_pseudo_sphere == True, although there is no documentation on
this. Default is 6371.0.</dd>
<dt><strong><code>user_angles</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Denote whether radiant quantities should be returned at user angles.
If False, radiant quantities are to be returned at computational
polar angles. Also, UMU will return the cosines of the computational
polar angles and n_polar (from ComputationalParameters) will return
their number ( = n_streams).UMU must
be large enough to contain n_streams elements. If True,
radiant quantities are to be returned at user-specified polar
angles, as follows: NUMU No. of polar angles (zero is a legal value
only when 'only_fluxes' == True ) UMU(IU) IU=1 to NUMU, cosines of
output polar angles in increasing order&mdash;starting with negative
(downward) values (if any) and on through positive (upward)
values; <strong><em> MUST NOT HAVE ANY ZERO VALUES </em></strong>. Default is True.</dd>
<dt><strong><code>user_optical_depths</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Denote whether radiant quantities are returned at user-specified
optical depths. Default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised if any inputs cannot be cast to the correct type.</dd>
<dt><code>ValueError</code></dt>
<dd>Raised if any inputs cannot be cast to the correct type or if
print_variables does not have 5 elements.</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<p>UserWarning
Raised if accuracy is not between 0 and 0.01.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelBehavior:
    &#34;&#34;&#34;Create a data structure for holding the DISORT control variables.

    ModelBehavior holds the control flags that dictate DISORT&#39;s behavior. It
    also performs basic checks that the input control options are plausible.

    &#34;&#34;&#34;
    def __init__(self, accuracy: float = 0.0, delta_m_plus: bool = False,
                 do_pseudo_sphere: bool = False, header: str = &#39;&#39;,
                 incidence_beam_conditions: bool = False,
                 only_fluxes: bool = False, print_variables: list[bool] = None,
                 radius: float = 6371.0, user_angles: bool = True,
                 user_optical_depths: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        accuracy: float, optional
            The convergence criterion for azimuthal (Fourier cosine) series.
            Will stop when the following occurs twice: largest term being added
            is less than &#39;accuracy&#39; times total series sum (twice because
            there are cases where terms are anomalously small but azimuthal
            series has not converged). Should be between 0 and 0.01 to avoid
            risk of serious non-convergence. Has no effect on problems lacking a
            beam source, since azimuthal series has only one term in that case.
            Default is 0.0.
        delta_m_plus: bool, optional
            Denote whether to use the delta-M+ method of Lin et al. (2018).
            Default is False.
        do_pseudo_sphere: bool, optional
            Denote whether to use a pseudo-spherical correction. Default is
            False.
        header: str, optional
            Use a 127- (or less) character header for prints, embedded in the
            DISORT banner. Input headers greater than 127 characters will be
            truncated. Setting header=&#39;&#39; will eliminate both the banner and the
            header, and this is the only way to do so (&#39;header&#39; is not
            controlled by any of the &#39;print&#39; flags); &#39;header&#39; can be used
            to mark the progress of a calculation in which DISORT is called many
            times, while leaving all other printing turned off. Default is &#39;&#39;.
        incidence_beam_conditions: bool, optional
            Denote what functions of the incidence beam angle should be
            included. If True, return the albedo and transmissivity of the
            entire medium as a function of incidence beam angle. In this case,
            the following inputs are the only ones considered by DISORT:

                - n_layers (from ComputationalParameters)
                - DTAUC
                - SSALB
                - PMOM
                - n_streams (from ComputationalParameters)
                - user_angles (from this class)
                - n_polar (from ComputationalParameters)
                - UMU
                - ALBEDO
                - print_variables (from this class)
                - header (from this class)

            PLANK is assumed to be False, LAMBER is assumed to be True, and
            ONLYFL must be False. The only output is ALBMED and TRNMED. The
            intensities are not corrected for delta-M+ correction.

            If False, this is accommodates any general case of boundary
            conditions including beam illumination from the top, isotropic
            illumination from the top, thermal emission from the top, internal
            thermal emission, reflection at the bottom, and/or thermal emission
            from the bottom. Default is False.
        only_fluxes: bool, optional
            Determine if only the fluxes are returned by the model. If True,
            return fluxes, flux divergences, and mean intensities; if False,
            return all those quantities and intensities. In addition, if True
            the number of polar angles can be 0, the number of azimuthal angles
            can be 0, phi is not used, and all values of intensity (UU) will be
            set to 0 (these are defined in ComputationalParameters). Default is
            False.
        print_variables: list[bool], optional
            Make a list of variables that control what DISORT prints. The 5
            booleans control whether each of the following is printed:

            1. Input variables (except PMOM)
            2. Fluxes
            3. Intensities at user levels and angles
            4. Planar transmissivity and planar albedo as a function of solar
            zenith angle (incidence_beam_conditions == True)
            5. PMOM for each layer (but only if 1. == True and only for layers
            with scattering)

            Default is None, which makes [False, False, False, False, False].
        radius: float, optional
            The planetary radius. This is presumably only used if
            do_pseudo_sphere == True, although there is no documentation on
            this. Default is 6371.0.
        user_angles: bool, optional
            Denote whether radiant quantities should be returned at user angles.
            If False, radiant quantities are to be returned at computational
            polar angles. Also, UMU will return the cosines of the computational
            polar angles and n_polar (from ComputationalParameters) will return
            their number ( = n_streams).UMU must
            be large enough to contain n_streams elements. If True,
            radiant quantities are to be returned at user-specified polar
            angles, as follows: NUMU No. of polar angles (zero is a legal value
            only when &#39;only_fluxes&#39; == True ) UMU(IU) IU=1 to NUMU, cosines of
            output polar angles in increasing order---starting with negative
            (downward) values (if any) and on through positive (upward)
            values; *** MUST NOT HAVE ANY ZERO VALUES ***. Default is True.
        user_optical_depths: bool, optional
            Denote whether radiant quantities are returned at user-specified
            optical depths. Default is False.

        Raises
        ------
        TypeError
            Raised if any inputs cannot be cast to the correct type.
        ValueError
            Raised if any inputs cannot be cast to the correct type or if
            print_variables does not have 5 elements.

        Warnings
        --------
        UserWarning
            Raised if accuracy is not between 0 and 0.01.

        &#34;&#34;&#34;
        self.__accuracy = self.__make_accuracy(accuracy)
        self.__delta_m_plus = self.__make_delta_m_plus(delta_m_plus)
        self.__do_pseudo_sphere = self.__make_do_pseudo_sphere(do_pseudo_sphere)
        self.__header = self.__make_header(header)
        self.__incidence_beam_conditions = \
            self.__make_incidence_beam_conditions(incidence_beam_conditions)
        self.__only_fluxes = self.__make_only_fluxes(only_fluxes)
        self.__print_variables = self.__make_print_variables(print_variables)
        self.__radius = self.__make_radius(radius)
        self.__user_angles = self.__make_user_angles(user_angles)
        self.__user_optical_depths = self.__make_user_optical_depths(
            user_optical_depths)

        self.__warn_if_accuracy_is_outside_valid_range()

    def __make_accuracy(self, accuracy: float) -&gt; float:
        return self.__cast_variable_to_float(accuracy, &#39;accuracy&#39;)

    def __make_delta_m_plus(self, delta_m_plus: bool) -&gt; bool:
        return self.__cast_variable_to_bool(delta_m_plus, &#39;delta_m_plus&#39;)

    def __make_do_pseudo_sphere(self, do_pseudo_sphere: bool) -&gt; bool:
        return self.__cast_variable_to_bool(
            do_pseudo_sphere, &#39;do_pseudo_sphere&#39;)

    # TODO: this does more than one thing
    @staticmethod
    def __make_header(header) -&gt; str:
        try:
            header = str(header)
            if len(header) &gt;= 127:
                header = header[:126]
            return header
        except TypeError as te:
            raise TypeError(&#39;header cannot be cast into a string.&#39;) from te

    def __make_incidence_beam_conditions(self, ibcnd: bool) -&gt; bool:
        return self.__cast_variable_to_bool(ibcnd, &#39;incidence_beam_conditions&#39;)

    def __make_only_fluxes(self, only_fluxes: bool) -&gt; bool:
        return self.__cast_variable_to_bool(only_fluxes, &#39;only_fluxes&#39;)

    # TODO: this does more than one thing
    @staticmethod
    def __make_print_variables(pvar) -&gt; list[bool]:
        if pvar is None:
            return [False, False, False, False, False]
        else:
            try:
                prnt = [bool(f) for f in pvar]
                if len(prnt) != 5:
                    raise ValueError(&#39;print_variables should have 5 elements.&#39;)
                return prnt
            except TypeError as te:
                raise TypeError(&#39;print_variables should be a list of bools&#39;) \
                    from te

    def __make_radius(self, radius: float) -&gt; float:
        radius = self.__cast_variable_to_float(radius, &#39;radius&#39;)
        self.__raise_value_error_if_radius_is_not_positive(radius)
        return radius

    def __make_user_angles(self, user_angles: bool) -&gt; bool:
        return self.__cast_variable_to_bool(user_angles, &#39;user_angles&#39;)

    def __make_user_optical_depths(self, user_optical_depths: bool) -&gt; bool:
        return self.__cast_variable_to_bool(
            user_optical_depths, &#39;user_optical_depths&#39;)

    @staticmethod
    def __cast_variable_to_float(variable: float, name: str) -&gt; float:
        try:
            return float(variable)
        except TypeError as te:
            raise TypeError(f&#39;{name} cannot be cast into a float.&#39;) from te
        except ValueError as ve:
            raise ValueError(f&#39;{name} cannot be cast into a float.&#39;) from ve

    @staticmethod
    def __cast_variable_to_bool(variable: bool, name: str) -&gt; bool:
        try:
            return bool(variable)
        except TypeError as te:
            raise TypeError(f&#39;{name} cannot be cast into a boolean.&#39;) from te

    @staticmethod
    def __raise_value_error_if_radius_is_not_positive(radius) -&gt; None:
        if radius &lt;= 0:
            raise ValueError(&#39;radius must be positive.&#39;)

    def __warn_if_accuracy_is_outside_valid_range(self) -&gt; None:
        if not 0 &lt;= self.__accuracy &lt;= 0.01:
            warn(&#39;accuracy is expected to be between 0 and 0.01.&#39;)

    @property
    def accuracy(self) -&gt; float:
        &#34;&#34;&#34;Get the input accuracy.

        Returns
        -------
        float
            The accuracy.

        Notes
        -----
        In DISORT, this variable is named &#34;ACCUR&#34;.

        &#34;&#34;&#34;
        return self.__accuracy

    @property
    def delta_m_plus(self) -&gt; bool:
        &#34;&#34;&#34;Get whether to use delta-M+ scaling.

        Returns
        -------
        bool
            True if delta-M+ scaling is requested; False otherwise.

        Notes
        -----
        In DISORT, this variable is named &#34;DELTAMPLUS&#34;. There is no
        documentation on this variable.

        &#34;&#34;&#34;
        return self.__delta_m_plus

    @property
    def do_pseudo_sphere(self) -&gt; bool:
        &#34;&#34;&#34;Get whether to perform a pseudo-spherical correction.

        Returns
        -------
        bool
            True if a pseudo-spherical correction is requested; False otherwise.

        Notes
        -----
        In DISORT, this variable is named &#34;DO_PSEUDO_SPHERE&#34;. There is no
        documentation on this variable.

        &#34;&#34;&#34;
        return self.__do_pseudo_sphere

    @property
    def header(self) -&gt; str:
        &#34;&#34;&#34;Get the characters that will appear in the DISORT banner.

        Returns
        -------
        str
            The characters in the DISORT banner.

        Notes
        -----
        In DISORT, this variable is named &#34;HEADER&#34;.

        &#34;&#34;&#34;
        return self.__header

    @property
    def incidence_beam_conditions(self) -&gt; bool:
        &#34;&#34;&#34;Get whether the model will only return albedo and transmissivity.

        Returns
        -------
        bool
            True if DISORT should only return albedo and transmissivity; False
            otherwise.

        &#34;&#34;&#34;
        return self.__incidence_beam_conditions

    @property
    def only_fluxes(self) -&gt; bool:
        &#34;&#34;&#34;Get whether DISORT should only return fluxes.

        Returns
        -------
        bool
            True if only fluxes are requested; False if fluxes and intensities
            are requested.

        Notes
        -----
        In DISORT, this variable is named &#34;ONLYFL&#34;.

        &#34;&#34;&#34;
        return self.__only_fluxes

    @property
    def print_variables(self) -&gt; list[bool]:
        &#34;&#34;&#34;Get the variables to print.

        Returns
        -------
        list[bool]
            The variables to print

        Notes
        -----
        In DISORT, this variable is named &#34;PRNT&#34;.

        &#34;&#34;&#34;
        return self.__print_variables

    @property
    def radius(self) -&gt; float:
        &#34;&#34;&#34;Get the planetary radius.

        Returns
        -------
        float
            The planetary radius.

        Notes
        -----
        In DISORT, this variable is named &#34;EARTH_RADIUS&#34;. There is no
        documentation on this variable, though I&#39;m presuming it could be any
        planetary radius.

        &#34;&#34;&#34;
        return self.__radius

    @property
    def user_angles(self) -&gt; bool:
        &#34;&#34;&#34;Get whether radiant quantities should be returned at user angles.

        Returns
        -------
        bool
            True if quantities are returned at user-specified angles; False if
            they are returned at computational polar angles.

        Notes
        -----
        In DISORT, this variable is named &#34;USRANG&#34;.

        &#34;&#34;&#34;
        return self.__user_angles

    @property
    def user_optical_depths(self) -&gt; bool:
        &#34;&#34;&#34;Get whether radiant quantities should be returned at user optical
        depths.

        Returns
        -------
        bool
            True if quantities are returned at user optical depths; False if
            they are returned at the boundary of every computational layer.

        Notes
        -----
        In DISORT, this variable is named &#34;USRTAU&#34;.

        &#34;&#34;&#34;
        return self.__user_optical_depths</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyRT_DISORT.controller.ModelBehavior.accuracy"><code class="name">var <span class="ident">accuracy</span> : float</code></dt>
<dd>
<div class="desc"><p>Get the input accuracy.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The accuracy.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "ACCUR".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accuracy(self) -&gt; float:
    &#34;&#34;&#34;Get the input accuracy.

    Returns
    -------
    float
        The accuracy.

    Notes
    -----
    In DISORT, this variable is named &#34;ACCUR&#34;.

    &#34;&#34;&#34;
    return self.__accuracy</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.delta_m_plus"><code class="name">var <span class="ident">delta_m_plus</span> : bool</code></dt>
<dd>
<div class="desc"><p>Get whether to use delta-M+ scaling.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if delta-M+ scaling is requested; False otherwise.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "DELTAMPLUS". There is no
documentation on this variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delta_m_plus(self) -&gt; bool:
    &#34;&#34;&#34;Get whether to use delta-M+ scaling.

    Returns
    -------
    bool
        True if delta-M+ scaling is requested; False otherwise.

    Notes
    -----
    In DISORT, this variable is named &#34;DELTAMPLUS&#34;. There is no
    documentation on this variable.

    &#34;&#34;&#34;
    return self.__delta_m_plus</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.do_pseudo_sphere"><code class="name">var <span class="ident">do_pseudo_sphere</span> : bool</code></dt>
<dd>
<div class="desc"><p>Get whether to perform a pseudo-spherical correction.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if a pseudo-spherical correction is requested; False otherwise.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "DO_PSEUDO_SPHERE". There is no
documentation on this variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def do_pseudo_sphere(self) -&gt; bool:
    &#34;&#34;&#34;Get whether to perform a pseudo-spherical correction.

    Returns
    -------
    bool
        True if a pseudo-spherical correction is requested; False otherwise.

    Notes
    -----
    In DISORT, this variable is named &#34;DO_PSEUDO_SPHERE&#34;. There is no
    documentation on this variable.

    &#34;&#34;&#34;
    return self.__do_pseudo_sphere</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.header"><code class="name">var <span class="ident">header</span> : str</code></dt>
<dd>
<div class="desc"><p>Get the characters that will appear in the DISORT banner.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The characters in the DISORT banner.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "HEADER".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def header(self) -&gt; str:
    &#34;&#34;&#34;Get the characters that will appear in the DISORT banner.

    Returns
    -------
    str
        The characters in the DISORT banner.

    Notes
    -----
    In DISORT, this variable is named &#34;HEADER&#34;.

    &#34;&#34;&#34;
    return self.__header</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.incidence_beam_conditions"><code class="name">var <span class="ident">incidence_beam_conditions</span> : bool</code></dt>
<dd>
<div class="desc"><p>Get whether the model will only return albedo and transmissivity.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if DISORT should only return albedo and transmissivity; False
otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def incidence_beam_conditions(self) -&gt; bool:
    &#34;&#34;&#34;Get whether the model will only return albedo and transmissivity.

    Returns
    -------
    bool
        True if DISORT should only return albedo and transmissivity; False
        otherwise.

    &#34;&#34;&#34;
    return self.__incidence_beam_conditions</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.only_fluxes"><code class="name">var <span class="ident">only_fluxes</span> : bool</code></dt>
<dd>
<div class="desc"><p>Get whether DISORT should only return fluxes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if only fluxes are requested; False if fluxes and intensities
are requested.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "ONLYFL".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def only_fluxes(self) -&gt; bool:
    &#34;&#34;&#34;Get whether DISORT should only return fluxes.

    Returns
    -------
    bool
        True if only fluxes are requested; False if fluxes and intensities
        are requested.

    Notes
    -----
    In DISORT, this variable is named &#34;ONLYFL&#34;.

    &#34;&#34;&#34;
    return self.__only_fluxes</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.print_variables"><code class="name">var <span class="ident">print_variables</span> : list</code></dt>
<dd>
<div class="desc"><p>Get the variables to print.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[bool]</code></dt>
<dd>The variables to print</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "PRNT".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def print_variables(self) -&gt; list[bool]:
    &#34;&#34;&#34;Get the variables to print.

    Returns
    -------
    list[bool]
        The variables to print

    Notes
    -----
    In DISORT, this variable is named &#34;PRNT&#34;.

    &#34;&#34;&#34;
    return self.__print_variables</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.radius"><code class="name">var <span class="ident">radius</span> : float</code></dt>
<dd>
<div class="desc"><p>Get the planetary radius.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The planetary radius.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "EARTH_RADIUS". There is no
documentation on this variable, though I'm presuming it could be any
planetary radius.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self) -&gt; float:
    &#34;&#34;&#34;Get the planetary radius.

    Returns
    -------
    float
        The planetary radius.

    Notes
    -----
    In DISORT, this variable is named &#34;EARTH_RADIUS&#34;. There is no
    documentation on this variable, though I&#39;m presuming it could be any
    planetary radius.

    &#34;&#34;&#34;
    return self.__radius</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.user_angles"><code class="name">var <span class="ident">user_angles</span> : bool</code></dt>
<dd>
<div class="desc"><p>Get whether radiant quantities should be returned at user angles.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if quantities are returned at user-specified angles; False if
they are returned at computational polar angles.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "USRANG".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user_angles(self) -&gt; bool:
    &#34;&#34;&#34;Get whether radiant quantities should be returned at user angles.

    Returns
    -------
    bool
        True if quantities are returned at user-specified angles; False if
        they are returned at computational polar angles.

    Notes
    -----
    In DISORT, this variable is named &#34;USRANG&#34;.

    &#34;&#34;&#34;
    return self.__user_angles</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.ModelBehavior.user_optical_depths"><code class="name">var <span class="ident">user_optical_depths</span> : bool</code></dt>
<dd>
<div class="desc"><p>Get whether radiant quantities should be returned at user optical
depths.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if quantities are returned at user optical depths; False if
they are returned at the boundary of every computational layer.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "USRTAU".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user_optical_depths(self) -&gt; bool:
    &#34;&#34;&#34;Get whether radiant quantities should be returned at user optical
    depths.

    Returns
    -------
    bool
        True if quantities are returned at user optical depths; False if
        they are returned at the boundary of every computational layer.

    Notes
    -----
    In DISORT, this variable is named &#34;USRTAU&#34;.

    &#34;&#34;&#34;
    return self.__user_optical_depths</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays"><code class="flex name class">
<span>class <span class="ident">OutputArrays</span></span>
<span>(</span><span>computational_params: <a title="pyRT_DISORT.controller.ComputationalParameters" href="#pyRT_DISORT.controller.ComputationalParameters">ComputationalParameters</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a data structure to make the DISORT output arrays.</p>
<p>OutputArrays creates arrays of 0s that are designed to get populated with
values as DISORT runs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>computational_params</code></strong> :&ensp;<code><a title="pyRT_DISORT.controller.ComputationalParameters" href="#pyRT_DISORT.controller.ComputationalParameters">ComputationalParameters</a></code></dt>
<dd>Data structure holding the model computational variables.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised if input is not an instance of ComputationalParameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputArrays:
    &#34;&#34;&#34;Create a data structure to make the DISORT output arrays.

    OutputArrays creates arrays of 0s that are designed to get populated with
    values as DISORT runs.

    &#34;&#34;&#34;

    def __init__(self, computational_params: ComputationalParameters) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        computational_params: ComputationalParameters
            Data structure holding the model computational variables.

        Raises
        ------
        TypeError
            Raised if input is not an instance of ComputationalParameters.

        &#34;&#34;&#34;
        self.__cp = computational_params

        self.__raise_type_error_if_input_is_not_cp()

        self.__albedo_medium = self.__make_albedo_medium()
        self.__diffuse_up_flux = self.__make_diffuse_up_flux()
        self.__diffuse_down_flux = self.__make_diffuse_down_flux()
        self.__direct_beam_flux = self.__make_direct_beam_flux()
        self.__flux_divergence = self.__make_flux_divergence()
        self.__intensity = self.__make_intensity()
        self.__mean_intensity = self.__make_mean_intensity()
        self.__transmissivity_medium = self.__make_transmissivity_medium()

    def __raise_type_error_if_input_is_not_cp(self) -&gt; None:
        if not isinstance(self.__cp, ComputationalParameters):
            raise TypeError(&#39;computational_params must be an instance of &#39;
                            &#39;ComputationalParameters.&#39;)

    def __make_albedo_medium(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_polar)

    def __make_diffuse_up_flux(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_diffuse_down_flux(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_direct_beam_flux(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_flux_divergence(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_intensity(self) -&gt; np.ndarray:
        return np.zeros((self.__cp.n_polar, self.__cp.n_user_levels,
                         self.__cp.n_azimuth))

    def __make_mean_intensity(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_user_levels)

    def __make_transmissivity_medium(self) -&gt; np.ndarray:
        return np.zeros(self.__cp.n_polar)

    @property
    def albedo_medium(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the albedo of the medium output array.

        Returns
        -------
        np.ndarray
            The albedo of the medium.

        Notes
        -----
        In DISORT, this variable is named &#34;ALBMED&#34;.

        &#34;&#34;&#34;
        return self.__albedo_medium

    @property
    def diffuse_up_flux(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the diffuse upward flux output array.

        Returns
        -------
        np.ndarray
            The diffuse upward flux.

        Notes
        -----
        In DISORT, this variable is named &#34;FLUP&#34;.

        &#34;&#34;&#34;
        return self.__diffuse_up_flux

    @property
    def diffuse_down_flux(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the diffuse downward flux output array, which will be the total
        downward flux minus the direct beam flux.

        Returns
        -------
        np.ndarray
            The diffuse downward flux.

        Notes
        -----
        In DISORT, this variable is named &#34;RFLDN&#34;.

        &#34;&#34;&#34;
        return self.__diffuse_down_flux

    @property
    def direct_beam_flux(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the direct beam flux output array.

        Returns
        -------
        np.ndarray
            The direct beam flux.

        Notes
        -----
        In DISORT, this variable is named &#34;RFLDIR&#34;.

        &#34;&#34;&#34;
        return self.__direct_beam_flux

    @property
    def flux_divergence(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the flux divergence output array, which is will represent
        (d(net_flux) / d(optical_depth)). This is an exact result.

        Returns
        -------
        np.ndarray
            The flux divergence.

        Notes
        -----
        In DISORT, this variable is named &#34;DFDT&#34;.

        &#34;&#34;&#34;
        return self.__flux_divergence

    @property
    def intensity(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the intensity output array.

        Returns
        -------
        np.ndarray
            The intensity.

        Notes
        -----
        In DISORT, this variable is named &#34;UU&#34;.

        &#34;&#34;&#34;
        return self.__intensity

    @property
    def mean_intensity(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the mean intensity output array.

        Returns
        -------
        np.ndarray
            The mean intensity.

        Notes
        -----
        In DISORT, this variable is named &#34;UAVG&#34;.

        &#34;&#34;&#34;
        return self.__mean_intensity

    @property
    def transmissivity_medium(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Get the transmissivity of the medium output array.

        Returns
        -------
        np.ndarray
            The transmissivity of the medium.

        Notes
        -----
        In DISORT, this variable is named &#34;TRNMED&#34;.

        &#34;&#34;&#34;
        return self.__transmissivity_medium</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyRT_DISORT.controller.OutputArrays.albedo_medium"><code class="name">var <span class="ident">albedo_medium</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the albedo of the medium output array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The albedo of the medium.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "ALBMED".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def albedo_medium(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the albedo of the medium output array.

    Returns
    -------
    np.ndarray
        The albedo of the medium.

    Notes
    -----
    In DISORT, this variable is named &#34;ALBMED&#34;.

    &#34;&#34;&#34;
    return self.__albedo_medium</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays.diffuse_down_flux"><code class="name">var <span class="ident">diffuse_down_flux</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the diffuse downward flux output array, which will be the total
downward flux minus the direct beam flux.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The diffuse downward flux.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "RFLDN".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def diffuse_down_flux(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the diffuse downward flux output array, which will be the total
    downward flux minus the direct beam flux.

    Returns
    -------
    np.ndarray
        The diffuse downward flux.

    Notes
    -----
    In DISORT, this variable is named &#34;RFLDN&#34;.

    &#34;&#34;&#34;
    return self.__diffuse_down_flux</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays.diffuse_up_flux"><code class="name">var <span class="ident">diffuse_up_flux</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the diffuse upward flux output array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The diffuse upward flux.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "FLUP".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def diffuse_up_flux(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the diffuse upward flux output array.

    Returns
    -------
    np.ndarray
        The diffuse upward flux.

    Notes
    -----
    In DISORT, this variable is named &#34;FLUP&#34;.

    &#34;&#34;&#34;
    return self.__diffuse_up_flux</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays.direct_beam_flux"><code class="name">var <span class="ident">direct_beam_flux</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the direct beam flux output array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The direct beam flux.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "RFLDIR".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def direct_beam_flux(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the direct beam flux output array.

    Returns
    -------
    np.ndarray
        The direct beam flux.

    Notes
    -----
    In DISORT, this variable is named &#34;RFLDIR&#34;.

    &#34;&#34;&#34;
    return self.__direct_beam_flux</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays.flux_divergence"><code class="name">var <span class="ident">flux_divergence</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the flux divergence output array, which is will represent
(d(net_flux) / d(optical_depth)). This is an exact result.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The flux divergence.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "DFDT".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flux_divergence(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the flux divergence output array, which is will represent
    (d(net_flux) / d(optical_depth)). This is an exact result.

    Returns
    -------
    np.ndarray
        The flux divergence.

    Notes
    -----
    In DISORT, this variable is named &#34;DFDT&#34;.

    &#34;&#34;&#34;
    return self.__flux_divergence</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays.intensity"><code class="name">var <span class="ident">intensity</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the intensity output array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The intensity.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "UU".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intensity(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the intensity output array.

    Returns
    -------
    np.ndarray
        The intensity.

    Notes
    -----
    In DISORT, this variable is named &#34;UU&#34;.

    &#34;&#34;&#34;
    return self.__intensity</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays.mean_intensity"><code class="name">var <span class="ident">mean_intensity</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the mean intensity output array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The mean intensity.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "UAVG".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean_intensity(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the mean intensity output array.

    Returns
    -------
    np.ndarray
        The mean intensity.

    Notes
    -----
    In DISORT, this variable is named &#34;UAVG&#34;.

    &#34;&#34;&#34;
    return self.__mean_intensity</code></pre>
</details>
</dd>
<dt id="pyRT_DISORT.controller.OutputArrays.transmissivity_medium"><code class="name">var <span class="ident">transmissivity_medium</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the transmissivity of the medium output array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The transmissivity of the medium.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>In DISORT, this variable is named "TRNMED".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transmissivity_medium(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Get the transmissivity of the medium output array.

    Returns
    -------
    np.ndarray
        The transmissivity of the medium.

    Notes
    -----
    In DISORT, this variable is named &#34;TRNMED&#34;.

    &#34;&#34;&#34;
    return self.__transmissivity_medium</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyRT_DISORT" href="index.html">pyRT_DISORT</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyRT_DISORT.controller.ComputationalParameters" href="#pyRT_DISORT.controller.ComputationalParameters">ComputationalParameters</a></code></h4>
<ul class="two-column">
<li><code><a title="pyRT_DISORT.controller.ComputationalParameters.n_azimuth" href="#pyRT_DISORT.controller.ComputationalParameters.n_azimuth">n_azimuth</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ComputationalParameters.n_layers" href="#pyRT_DISORT.controller.ComputationalParameters.n_layers">n_layers</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ComputationalParameters.n_moments" href="#pyRT_DISORT.controller.ComputationalParameters.n_moments">n_moments</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ComputationalParameters.n_polar" href="#pyRT_DISORT.controller.ComputationalParameters.n_polar">n_polar</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ComputationalParameters.n_streams" href="#pyRT_DISORT.controller.ComputationalParameters.n_streams">n_streams</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ComputationalParameters.n_user_levels" href="#pyRT_DISORT.controller.ComputationalParameters.n_user_levels">n_user_levels</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyRT_DISORT.controller.ModelBehavior" href="#pyRT_DISORT.controller.ModelBehavior">ModelBehavior</a></code></h4>
<ul class="">
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.accuracy" href="#pyRT_DISORT.controller.ModelBehavior.accuracy">accuracy</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.delta_m_plus" href="#pyRT_DISORT.controller.ModelBehavior.delta_m_plus">delta_m_plus</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.do_pseudo_sphere" href="#pyRT_DISORT.controller.ModelBehavior.do_pseudo_sphere">do_pseudo_sphere</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.header" href="#pyRT_DISORT.controller.ModelBehavior.header">header</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.incidence_beam_conditions" href="#pyRT_DISORT.controller.ModelBehavior.incidence_beam_conditions">incidence_beam_conditions</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.only_fluxes" href="#pyRT_DISORT.controller.ModelBehavior.only_fluxes">only_fluxes</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.print_variables" href="#pyRT_DISORT.controller.ModelBehavior.print_variables">print_variables</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.radius" href="#pyRT_DISORT.controller.ModelBehavior.radius">radius</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.user_angles" href="#pyRT_DISORT.controller.ModelBehavior.user_angles">user_angles</a></code></li>
<li><code><a title="pyRT_DISORT.controller.ModelBehavior.user_optical_depths" href="#pyRT_DISORT.controller.ModelBehavior.user_optical_depths">user_optical_depths</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyRT_DISORT.controller.OutputArrays" href="#pyRT_DISORT.controller.OutputArrays">OutputArrays</a></code></h4>
<ul class="">
<li><code><a title="pyRT_DISORT.controller.OutputArrays.albedo_medium" href="#pyRT_DISORT.controller.OutputArrays.albedo_medium">albedo_medium</a></code></li>
<li><code><a title="pyRT_DISORT.controller.OutputArrays.diffuse_down_flux" href="#pyRT_DISORT.controller.OutputArrays.diffuse_down_flux">diffuse_down_flux</a></code></li>
<li><code><a title="pyRT_DISORT.controller.OutputArrays.diffuse_up_flux" href="#pyRT_DISORT.controller.OutputArrays.diffuse_up_flux">diffuse_up_flux</a></code></li>
<li><code><a title="pyRT_DISORT.controller.OutputArrays.direct_beam_flux" href="#pyRT_DISORT.controller.OutputArrays.direct_beam_flux">direct_beam_flux</a></code></li>
<li><code><a title="pyRT_DISORT.controller.OutputArrays.flux_divergence" href="#pyRT_DISORT.controller.OutputArrays.flux_divergence">flux_divergence</a></code></li>
<li><code><a title="pyRT_DISORT.controller.OutputArrays.intensity" href="#pyRT_DISORT.controller.OutputArrays.intensity">intensity</a></code></li>
<li><code><a title="pyRT_DISORT.controller.OutputArrays.mean_intensity" href="#pyRT_DISORT.controller.OutputArrays.mean_intensity">mean_intensity</a></code></li>
<li><code><a title="pyRT_DISORT.controller.OutputArrays.transmissivity_medium" href="#pyRT_DISORT.controller.OutputArrays.transmissivity_medium">transmissivity_medium</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>